//@ts-nocheck
import { useState, useCallback } from 'react';
import { ClaudeAPIService } from '../services/claudeAPI';
import { googleCalendarService } from '../services/googleCalendar';
import type { Message, ClaudeConfig, Attachment } from '../types';

export const useClaudeChat = () => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const apiKey = import.meta.env.VITE_ANTHROPIC_API_KEY;
  const claudeService = new ClaudeAPIService(apiKey);

  // üÜï D√âTECTION : Mots-cl√©s pour lire l'agenda
  const detectCalendarKeywords = (text: string): boolean => {
    const keywords = [
      'agenda', 'rendez-vous', 'rdv', 'planning', '√©v√©nements', 
      '√©v√©nement', 'calendar', 'calendrier', 'rendezvous'
    ];
    
    const lowerText = text.toLowerCase();
    return keywords.some(keyword => lowerText.includes(keyword));
  };

  // üÜï D√âTECTION : Mots-cl√©s pour cr√©er un √©v√©nement
  const detectCreateEventKeywords = (text: string): boolean => {
  const createKeywords = [
    // Fran√ßais
    'ajoute', 'cr√©e', 'planifie', 'programme', 'r√©serve', 
    'bloque', 'prends', 'mets', 'organise', 'fixe',
    // Anglais
    'add', 'create', 'schedule', 'plan', 'book', 
    'set', 'make', 'organize', 'arrange'
  ];
  
  const eventKeywords = [
    // Fran√ßais
    'rdv', 'rendez-vous', 'rendezvous', '√©v√©nement', '√©v√©nements',
    'consultation', 's√©ance', 'r√©union',
    // Anglais  
    'appointment', 'meeting', 'event', 'session', 'consultation'
  ];
  
  const lowerText = text.toLowerCase();
  
  const hasCreateWord = createKeywords.some(keyword => lowerText.includes(keyword));
  const hasEventWord = eventKeywords.some(keyword => lowerText.includes(keyword));
  
  return hasCreateWord && hasEventWord;
};

  // üÜï FONCTION : Extraire les infos d'un √©v√©nement avec Claude
  const extractEventInfo = async (text: string): Promise<any> => {
    try {
      const extractionPrompt = `
Analyse cette demande et extrait les informations pour cr√©er un √©v√©nement Google Calendar.

Demande: "${text}"

R√©ponds UNIQUEMENT avec un JSON valide dans ce format exact:
{
  "title": "titre de l'√©v√©nement",
  "date": "YYYY-MM-DD",
  "time": "HH:MM",
  "duration": 60,
  "description": "description optionnelle"
}

R√®gles:
- Si pas de date pr√©cise, utilise demain
- Si pas d'heure pr√©cise, utilise 09:00
- Si pas de dur√©e pr√©cise, utilise 60 minutes
- Le titre doit √™tre descriptif
- Si "matin" = 09:00, "apr√®s-midi" = 14:00, "soir" = 18:00

Exemple:
"Ajoute un RDV avec Marie demain √† 14h" ‚Üí 
{
  "title": "RDV avec Marie",
  "date": "2025-07-02",
  "time": "14:00", 
  "duration": 60,
  "description": "Rendez-vous avec Marie"
}
`;

      const extractionMessages = [{
        role: 'user' as const,
        content: [{
          type: 'text' as const,
          text: extractionPrompt
        }]
      }];

      const extraction = await claudeService.sendMessage(extractionMessages, {
        model: 'claude-sonnet-4-20250514',
        maxTokens: 300,
      });

      // Parser le JSON de Claude
      const jsonMatch = extraction.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
      
      throw new Error('Impossible d\'extraire les informations de l\'√©v√©nement');
      
    } catch (error) {
      console.error('‚ùå Erreur extraction √©v√©nement:', error);
      throw error;
    }
  };

  // üÜï FONCTION : Cr√©er un √©v√©nement Google Calendar
  const createCalendarEvent = async (eventInfo: any): Promise<string> => {
    try {
      // Construire les dates de d√©but et fin
      const startDateTime = new Date(`${eventInfo.date}T${eventInfo.time}:00`);
      const endDateTime = new Date(startDateTime.getTime() + (eventInfo.duration * 60000));

      const event = {
        summary: eventInfo.title,
        description: eventInfo.description || '',
        start: {
          dateTime: startDateTime.toISOString(),
          timeZone: 'Europe/Paris'
        },
        end: {
          dateTime: endDateTime.toISOString(),
          timeZone: 'Europe/Paris'
        }
      };

      const createdEvent = await googleCalendarService.createEvent(event);
      
      const formattedDate = startDateTime.toLocaleDateString('fr-FR', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });

      return `\n\n‚úÖ **√âv√©nement cr√©√© avec succ√®s !**\n\nüìÖ **${eventInfo.title}**\nüïê ${formattedDate}\n‚è±Ô∏è Dur√©e: ${eventInfo.duration} minutes\n\nL'√©v√©nement a √©t√© ajout√© √† votre Google Calendar.`;
      
    } catch (error) {
      console.error('‚ùå Erreur cr√©ation √©v√©nement:', error);
      return `\n\n‚ùå **Erreur lors de la cr√©ation de l'√©v√©nement:** ${error instanceof Error ? error.message : 'Erreur inconnue'}`;
    }
  };

  // FONCTION EXISTANTE : R√©cup√©rer et formater les √©v√©nements
  const getCalendarEvents = async (): Promise<string> => {
    try {
      const events = await googleCalendarService.getEvents(10);
      
      if (events.length === 0) {
        return "\n\nüìÖ **Agenda :** Aucun √©v√©nement trouv√© dans votre calendrier.";
      }

      let calendarText = "\n\nüìÖ **Voici vos prochains rendez-vous :**\n\n";
      
      events.forEach((event, index) => {
        const title = event.summary || 'Sans titre';
        let dateTime = '';
        
        if (event.start?.dateTime) {
          const date = new Date(event.start.dateTime);
          dateTime = date.toLocaleDateString('fr-FR', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
          });
        } else if (event.start?.date) {
          const date = new Date(event.start.date);
          dateTime = date.toLocaleDateString('fr-FR', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric'
          }) + ' (toute la journ√©e)';
        }

        calendarText += `**${index + 1}.** ${title}\n`;
        calendarText += `üìÖ ${dateTime}\n`;
        if (event.location) {
          calendarText += `üìç ${event.location}\n`;
        }
        calendarText += '\n';
      });

      return calendarText;
    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration agenda:', error);
      return "\n\nüìÖ **Agenda :** Impossible de r√©cup√©rer vos √©v√©nements pour le moment.";
    }
  };

  const sendMessage = useCallback(async (
    content: string,
    attachments: Attachment[] = [],
    config: ClaudeConfig
  ) => {
    if (!content.trim() && attachments.length === 0) return;

    setError(null);
    
    const userMessage: Message = {
      id: Date.now().toString(),
      role: 'user',
      content,
      attachments,
      timestamp: new Date(),
    };

    const updatedMessages = [...messages, userMessage];
    setMessages(updatedMessages);
    setIsLoading(true);

    try {
      let enhancedContent = content;
      let actionPerformed = false;

      // üÜï PRIORIT√â 1 : Cr√©er un √©v√©nement
      if (detectCreateEventKeywords(content)) {
        console.log('üÜï Cr√©ation d\'√©v√©nement d√©tect√©e...');
        try {
          const eventInfo = await extractEventInfo(content);
          console.log('üìã Infos extraites:', eventInfo);
          const creationResult = await createCalendarEvent(eventInfo);
          enhancedContent = content + creationResult;
          actionPerformed = true;
        } catch (error) {
          console.error('‚ùå Erreur cr√©ation:', error);
          enhancedContent = content + `\n\n‚ùå Impossible de cr√©er l'√©v√©nement: ${error instanceof Error ? error.message : 'Erreur inconnue'}`;
        }
      }
      
      // PRIORIT√â 2 : Lire l'agenda (si pas de cr√©ation)
      else if (detectCalendarKeywords(content)) {
        console.log('üîç Lecture agenda d√©tect√©e...');
        const calendarData = await getCalendarEvents();
        enhancedContent = content + calendarData;
        actionPerformed = true;
      }

      const claudeMessages = ClaudeAPIService.prepareMessages([
        ...updatedMessages.slice(0, -1),
        { ...userMessage, content: enhancedContent }
      ]);
      
      const response = await claudeService.sendMessage(claudeMessages, config);

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: response,
        timestamp: new Date(),
      };

      setMessages(prev => [...prev, assistantMessage]);
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erreur inconnue';
      setError(errorMessage);
      
      const errorMsg: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: `‚ùå Erreur: ${errorMessage}`,
        timestamp: new Date(),
      };
      setMessages(prev => [...prev, errorMsg]);
    } finally {
      setIsLoading(false);
    }
  }, [messages, claudeService]);

  const clearMessages = useCallback(() => {
    setMessages([]);
    setError(null);
  }, []);

  return {
    messages,
    isLoading,
    error,
    sendMessage,
    clearMessages,
  };
};